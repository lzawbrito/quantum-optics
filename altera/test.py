from free_running_4detectors import * 

print(encode7bit(244))
a = bytearray(b"\xfft\x01\x00\x00\x00d\x01\x00\x00\x00a\x01\x00\x00\x00R\x01\x00\x00\x00\x08\x01\x00\x00\x00\x03\x01\x00\x00\x00p\x01\x00\x00\x00\x14\x01\x00\x00\x00\xffl\x00\x00\x00\x00]\x01\x00\x00\x00E\x01\x00\x00\x00/\x00\x00\x00\x00\x11\x00\x00\x00\x00.\x00\x00\x00\x00)\x00\x00\x00\x00d\x01\x00\x00\x00\xff6\x01\x00\x00\x00\x18\x01\x00\x00\x00 \x01\x00\x00\x00o\x00\x00\x00\x00/\x00\x00\x00\x00O\x01\x00\x00\x00\x19\x00\x00\x00\x00N\x01\x00\x00\x00\xffp\x00\x00\x00\x00M\x01\x00\x00\x00S\x01\x00\x00\x00\n\x01\x00\x00\x000\x00\x00\x00\x00r\x01\x00\x00\x00x\x00\x00\x00\x00\'\x01\x00\x00\x00\xff\x17\x01\x00\x00\x00\x01\x01\x00\x00\x00v\x00\x00\x00\x006\x01\x00\x00\x00J\x00\x00\x00\x00[\x01\x00\x00\x00\x04\x01\x00\x00\x00\x16\x01\x00\x00\x00\xff4\x01\x00\x00\x00V\x01\x00\x00\x00\x0e\x01\x00\x00\x00?\x00\x00\x00\x00#\x00\x00\x00\x00\x1e\x01\x00\x00\x00I\x01\x00\x00\x00\x12\x01\x00\x00\x00\xffi\x01\x00\x00\x00m\x00\x00\x00\x00h\x00\x00\x00\x00q\x00\x00\x00\x00\x06\x00\x00\x00\x00\x11\x01\x00\x00\x00(\x01\x00\x00\x00p\x01\x00\x00\x00\xff")
length = 1
data_len = 41 * (length * 10) + 40 
clean_data = clean_up_data(a, data_len)

for i in clean_data: 
	print(i)


counts = np.zeros(8, dtype=int)

times = np.arange(0, 41 * length, 41)
print(times)
detector_pairs = np.arange(0, 8)

print()
l = 0
for d in detector_pairs: 
	# loop through time 
	for t in times:
		print(t)
		cd = clean_data[(d + l + t):(d + l + t + 5)]
		print(d + l + t,  d + l + t + 5)
		print(cd) 
		print(len(cd))
		print(decode_int(cd))
		print('===')
		count_from_data = decode_int(clean_data[(d + l + t):(d + l + t + 5)])
		# print(count_from_data)
		counts[d] = counts[d] + count_from_data

		l += 4 # move forward 5 bytes for next detector pair (i.e., 4 indices)

print(counts)